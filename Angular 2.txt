- Okej då kör vi.
- Som ni redan vet så kommer huvud fokus av denna presentation och kväll vara tillängnad åt Angular 2 men för att vi alla ska vara på någolunda samma sida så tänkte jag gå igenom lite förkunskaper först.

- Detta får mig att hoppa direkt på ES6
ES6
- Eller Harmony som det kanske kallas
Harmony
- Eller ECMAScript version 6 om man vill vara tydlig
ECMAScript version 6
- Eller ES2015 som det nu officielt heter
ES2015
- Kärt barn har många namn. Utan att gå in på några ditaljer vad ecmascript är för något så kan vi säga att det är specifikationen av javascript, typ (egentligen är javascript bara en dialekt av ecmascript).
- Och ES6 är en big deal för javascrip världen.
- Varför? Låt oss bara lite snabbt kolla på tids axlen:

97: ES1
98: ES2 inga direkta nyheter
99: ES3 regular expressions and try/catch
- Woop Woop
- Man ska komma ihåg att internet var inte så stort 1999, PC hade precis börjat letat sig in i vart och varanat hem
- Åtta år senare kommer en stort genombrott, vi skulle få classer, ett modul system, statisk typning, iteratorer. Detta skulle bli stort.
07: ES4 classer, modul system, typ system, iteratorer
- ES4 kom aldrig ut. Vi behöver inte gå in på några ditaljer med det har något att göra med att Microsoft ansåg att silver light och flash skulle ta över världen
- Det kan vara lätt att hacka på Microsoft så här i efterhand med IE6 och allt men om saningen ska fram så har microsoft gjort mycket för webben när denna tid begav sig. Det är bara synd att de inte tog hand om sitt arv.
09: ES5!
- Vi fick 'strict mode'! Wee, som vi hade väntat.
15: ES6!
- Vi fick nästan allt som ES4 skulle ha varit för 8 år sedan.
16: ES7!
- En massa nytt.

- Okej, så låt oss böja med några nyhter i ES6, jag kommer inte hinna ta upp alla. Utan detta kommer bara bli ett utplock för att ni enklare ska kunna sätta in er i Angular
Class
- Jag skulle nog kunna hålla i en egen lunch dragning om classer och varför man bör undvika dem.

class Person {

    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    fulName() {
        return this.firstName + ' ' + this.lastName;
    }

}

– Det är inga konstigheter är. Det finns inga privata medlemmar. Ungefär som i python. Det finns dock förslag på privata medlemmar till es7.

Arrow function

- Detta är en av functionerna som javascript saknade mest. javascript är i regel enekl trådat, vilket gör att allt sker asyncront. Vilket gör att vi måste ha callbacks
enkel tråd => async => classback => lamda functioner

function add(a, b) { return a + b; }
detta är (i grova lag) samma sak som:
var add = function(a, b) { return a + b; };
som du skriva som:
var add = (a, b) => a + b;
En kommentar runt detta:

var fun = () => 1; // returns 1
var fun = () => {a: 1}; // returns undefined
Faktum är att det är samma sak som:
var fun = () => {
    (a: 1)
};
Vilket beter sig på samma sätt som:
var fun = function() {
    a: 1
};
Det är en valid syntax men det gör inget.
Kontenta. Om man vill retunera ett object så måste man wrappa det i parentecer:

var fun = () => ({a: 1});
eller:
var fun = () => {
    return {a: 1};
}

Template strings

- I javascript kan ' användas på samma sätt som " dock har vi saknat något sätt att deklarera multilines men nu har vi `

var s = [
    'Fist long line',
    'next long line',
    'My name is: ' + name
].join('\n');

var s = `
    Fist long line
    next long line
    My name is: ${name}
`;

Destructuring, Default and the Rest
- Detta används och om ni inte har använt det för ut i javascript så kan det ta ett tag för att bli van vid syntaxen:

var numbers = [1, 2, 3];
var [one, two] = numbers;
var [one, ...rest] = numbers;

- Okej, låt oss krongla till det med object:
var num = {x: 1, y: 2};
var {x, y} = num;

- Okej, fortrande ganska enkelt.
var num = {x: 1, y: 2};
var {x: a, y: b} = num;
- // a === 1, b === 2

- Vi kan ha default parameters
var num = {x: 1};
var {x: a, y: b = 2} = num;

- Vi kan också gå på djupet när vi matchar:
var num = { x: [{ foo: 1, bar: 2 }, {}], y: 2 };
var { x: [{foo: a}] = 2 } = num; // a = 1
http://giphy.com/gifs/awkward-miss-universe-philippines-26tOXN8rltzRWOh8s

Okej, några verkliga exempel:
var fn = require('fn');
var {path} = fn;

var {element, index} = findElement(1, [1, 2]);
var {element} = findElement(1, [1, 2]);
var {index} = findElement(1, [1, 2]);

var m = new Map()
m.set('a', 1)

for (var [key, value] of m) {
  console.log(key + ' is ' + value);
}

httpClient.get(url, ({body}) => {
   console.log(body);
});

function fun({a, b}) {
    return a + b;
}
fun({b: 2, a: 1});

function fun(a, b, ...args) {}
f(1, 2, 3, 4); // a = 1, b = 2, args = [3, 4]

Math.min(...[-1, 5, 11, 3])

let [, year, month, day] = /^(\d\d\d\d)-(\d\d)-(\d\d)$/.exec('2016-02-12');

Iterators Generators
function* test() {
    yield 0;
    yield 1;
    return;
}

- Det som kan skilja sig från andra språk är att man kan trycka tillbaka värden. Man brukar prata om push och pull.
function* test() {
    const n = yield 0;
    yield n + 1;
    return;
}

const gen = test();

console.log(gen.next().value);
console.log(gen.next(2).value)

for of
let a = [3, 5, 7];
a.foo = "hello";

for (let i in a) {
   console.log(i); // logs "0", "1", "2", "foo"
}

for (let i of a) {
   console.log(i); // logs "3", "5", "7"
}

- Om a är undefined: Cannot read property 'Symbol(Symbol.iterator)' of undefined, så att så länge man arbetar med arrays så finns det ingen anledning att inte använda .forEatch

a.forEatch(i => console.log(i));

Modules
- Detta är något som javascript har behövt väldigt länge. Och som vi egentligen har haft tack vare node js.

Och i node.js så kan vi skapa moduler på följande vis:
-- commonjs
circle.js
exports.area = r => {
  return 3.14 * r * r;
};

const circle = require('./circle.js');
circle.area(2)

-- AMD
define(['circle'], () => {

    return {
        area(r) {
          return 3.14 * r * r;
        }
    };

});

require(['circle'], circle => {
    circle.area(2);
});

-- systemJS
import circle from "./circle.js";
circle.area(2);

define(function() {
  return {
      area(r) {
        return 3.14 * r * r;
      }
  };
});


Promises


Tail Calls
- Wii, detta kommer ni kanske inte ikontakt med idag men det gör att man kan skriva funktionel programering i javascript på allval

ES7
- System global: https://github.com/tc39/proposal-global
- Call constructor: https://github.com/tc39/ecma262/blob/master/workingdocs/callconstructor.md
- observable: https://github.com/zenparsing/es-observable
- decorators: https://github.com/wycats/javascript-decorators/blob/master/README.md
- async/await https://github.com/tc39/ecmascript-asyncawait
- SIMD: http://tc39.github.io/ecmascript_simd/
- This binding: https://github.com/zenparsing/es-function-bind

Decorators
- Vad är decorators? Om ni har arbetat med pythons decorators så kommer ni känna er hemma annars så kommer här en snabb genomgång

- Låt oss säga att vi har en enkel klass:

class Heisenberg {

    constructor() {
        ...
    }

}

- Låt oss nu säga att vi vill lägga på meta data

@canCook
class Heisenberg {

    constructor() {
        ...
    }

}

function canCook(target) {
    target.canCook = true;
}

- Och vad är det som är fantastiskt med detta?
- Detta möjliggör att vi kan lägga på egensaker som kan senare användas. Ex:

@template(`
    <button>Click me</button>
`)
class ButtonController {

}

Och det stannar så klart inte här utan man kan göra ganska mycket med decorators. I sommras skrev jag en dependncy injector med hjälp av decorators (och typescript):

import {autoInject, dependencyInjection} from 'autoinject';

class User {
    test = 'It works fine';
}

@autoInject
class Db {

    user: User;

    constructor(user: User) {
        this.user = user;
    }
}

@autoInject
class MyClass {

    db: Db;

    constructor(db: Db) {
        this.db = db;
    }
}

const myClass = dependencyInjection(MyClass);

console.log(myClass.db.user.test);

Okej, så hur funkar det?

Låt oss säga att vi har följande klass:

class MrWhite {

    name = 'Heisenberg';

    knocking() {
        return 'I am the one who knocks.';
    }

}

Och vi vill att `name` inte ska vara skrivbar. Nu har vi några olika alternativ:

1:
Göra det till en get function:

...
    get name() {
        return 'Heisenberg';
    }
...
2:
class MrWhite {

    knocking() {
        return 'I am the one who knocks.';
    }

}
Object.defineProperty(MrWhite.prototype, 'name', {
  value: 'Heisenberg',
  writable: false
});

- Eller så decorerar man medlemmen:

class MrWhite {

    @readOnly name = 'Heisenberg';

    knocking() {
        return 'I am the one who knocks.';
    }

}

function readOnly(target, name, descriptor) {
    descriptor.writable = false;
}

– Låt oss säga att man vill skicka med att argument:
class MrWhite {

    @readOnly(true)
    name = 'Heisenberg';

    knocking() {
        return 'I am the one who knocks.';
    }

}

function readOnly(isReadOnly) {
    return (target, name, descriptor) => {
        descriptor.writable = !isReadOnly;
    }
}

- Låt oss gå in i lite mer ditalj:

@canCook(true)
class MrWhite {
}

Detta är samma sak som:
var MrWhite = (function () {
  class MrWhite {
  }

  MrWhite = canCook(true)(MrWhite) || MrWhite;
  return MrWhite;
})();



class MyClass {

    @memorizeFor(1000)
    fetchFromServer(delta) {
        ...
    }

    @trace()
    complexFunction() {
        ...
    }

}


- Tiden då man kunde skriva javascript utan att först kompilera den är förbi
- Varför då?
- Om man skriver javascript idag så vill man garanterat använda några av ES6 funktionaliteten
- Bild från ES6 tabellen
- Vi har länge varit tvungna att använda det globala namespace. Alla object binds till winodow (eller global) och det kan vara extremt svårt att följa beroenden.
- Man vill inte ha det så.
- Låt oss gå på en tidsresa igen.
- Jag har inga årtal men det är så här jag ser det

- HTTP anrop har altid varit dyrt.
- Detta har gjort att vi alltid har velat minimera javascript och css kod samt kompremera bilder
- Detta har gjort att vi sedan länge har behövt någon form av byggsteg innan koden når produktion
- 2011 kom Grunt som fick stort genomslag med denna typ av arbete. I Grunt skapar man helt eneklet en configurations fil som definerar vilka typer av arbeten som skall utföras och p åvilket sett.
- Det brukar vara standard arbeten som att komprimera javascrip och css. Problemet här var att det var just en konfigurations fil.
- Gulp kom för att lösa detta. Instället för att skriva konfigurationsfiler så kunde man nu progematiskt skriva kod som löser sina problem. gulp blev som en mini alfred och som i sig egentligen är ett ganska
litet ramverk.
- Så både grunt och gulp löser samma problem på ungefär samma sätt men grunt löser allt med konfigurations filer och i gulp programerar man script som löser problemen.
- Gulp gör detta riktigt snyggt genom att använda strömar.

- För ungefär två år sedan kom de första utfastet på ES6 och internet (jag) blev eld och lågor över att få börja använda det. Många av de nya funktionerna som precenteras i ES6 kan man skriva i ES5.
Det är bara en fråga om vilja. Det började dyka upp lite olika projekt som kompilerade ES6 till ES5 (ja, jag säger kompilera. Man tar kod som indata och ger ut kod som utdata, dvs en kompilator). Atscript var stort
men så kom ett projet som hete 6to5 och som var otroligt enkelt att sätta igång. Detta projekt bytte sedan namn till Babel och som nu är helt dominerande när det kommer till att kompilera ES6 och ES7 till ES5.

# lite exempelkod och bilder och länkar

Ett problem kvarstår dock.
Om vi använder moduler som man vill använda så går det inte riktigt att kompilera ner. Det finns ingen direkt motsvarighet.
a.ja => a.js
b.js => b.js

Det finns lite olika lösningar på problemet ingen klockren.

Browserfy är den gamla räven i gemet.
Vad Browserfy gör är egntligen att den länkar samman alla filer och försöker mocka betendet som nodejs har. Så den skapar funktioner som require och module.

Browserfy är ett otroligt litet fiffit verktyg och dess styrka ligger i att det är litet och att det bara gör en sak och att de gör det väl. Detta är också dess stora problem.
För detta betyder att man fortfarande måste använda gulp eller liknande verkyyg. Detta betyder att man måste underhålla ganska stora bygg system för att bygga en ganska enkel webbapp. Och detta brukar vara
överväldigande för utvecklare som är vana vid att kunna ändra sina javascript filer och kunna ladda om sidan.

Nu kom systemJS.
SystemJS som vi diskutera tidigare gör just detta. Du importerar en fil och sedan laddas alla in vid sidan av.
# Exempelkod för system js
Detta är ju super nice. Okej, vi måste göra ganska många http request men vad gör det när HTTP/2 är på ingång? Då spelar det ingen roll längre hur många anropp vi gör.
Eller? - Ja, teoretiskt så spelar inte antalat anrop någon roll längre.
Men eftersom vi bara efterfråger en js fil så måste vi dynamiskt tareda på vilka andra filer vi behöver.
- träd
-
- Babel är nice. Det är bra sturktur på det och det är enkelt att skriva egna plugins, detta gör också att finns support för det för nästan alla verktyg.
Typning i javascript

Typescript
- Alla vettiga språka har några olika datatyper. Eller hur?
- I javascript har vi 7 olika typer:
Boolean, Null, Undefined, Number, String, Symbol och Object.
- typeof Array() === 'object'
- typeof ( new Map() ) === 'object'
- Man kan tycka vad man vill om typning men eftersom vi uppenbarlige har olika datatyper så är det ide att annotera metoder.

Tänk er att man har följande kod:
const obj = {
    firstNumber: 1,
    secondNumber: 2,
    threadNumber: 3
};

function add(a, b, c) {
    return a + b + c;
}

const result = add(obj.firstNumber, obj.secondNumber, obj.threadNunber);
console.log(result);

- Låt oss ta ett annat exempel:

function area(r) {
    return Math.PI * r * r;
}

const result = area('1O');

- Detta skulle dock lösas om vi gav lite information till functionen:

function area(r: number): number {
    return Math.PI * r * r;
}

Okej, så vad inebär detta?
Jo, Vi har en funktion som tar emot ett argument och det argumentet måste vara ett number och sedan returnerar funktionen ett number.

Typescript hjälper till med detta. Dock kan det också sätta keppar i hjulet.

const obj = {};
obj.name = 'Mr. White'; // Property 'name' does not exist on type {}.

- Vilket är förvisso sant MEN det hindrar mig från att programera javascript. Om ni börjar använda typescript så kommer ni springa på minor. Alla gör det och typescript är inte felfritt
- Jag tror att jag har rapporterart ett tiotal buggar.
Vissa är inte återgärdade.

Till exempel:

Låt oss säga att vi har följande kod:

let a = 1;

if (true) {
    a = 2;
}

export {a};

import {a} from './a.js';
console.log(a); // 1


let a = 1;
export {a};

if (true) {
    a = 2;
}


Så det finns problem men det finns också stora fördelar, så pass stroa fördelar som har gjort vänt mig från att vara emot typescript till att använda det i nästa alla mina projekt (både frontend och backend).

Typescript ska vara ett hjälpmedel. Om det är ivägen. Använd `any` type.

Till exempel. Om ni vill kunna

const obj = {};
obj.name = 'Mr. White'; // Property 'name' does not exist on type {}.

Säg att obj är av any-type:

const obj: any = {};
obj.name = 'Mr. White';

Syntaxen kan vara lite förvirrande i vissa sammanhang men man kommer över det efter ett tag.

En av de stora fördelarna är att kunna definera interface:

interface tvShow {
    title: string;
    runtime: number;
    airDate: Date;
    genre: string[];
    episode: episode[];
}

function fetchTvShowsFromServer(): tvShow {
    return http.get('breaking-bad');
}

- The bad part of typescript. Typescript är en kompilator. Vad man egentligen vill ha är bara en typecheck. Inget mer. Jag vill att typescript ska analysera min javascript kod och sen är det upp till mig vad jag vill göra med den.
- Kodbasen på typescript är inte den bästa som jag har sett. De har få men stora filer. Det är inget ovanligt med 16k rader. Detta ska dock lösas till version 2.
- Typescript är buggit. Ni kommer sanoligt stöta på nya buggar.
- Dock börjar det komma upp lite andra alternativ: Flow från facebook är lovande. Detta gör ingen kompelering. Det är snabbt. Facebook har ju också utvecklat React och mycket annat så de vet vad de sysslar med.
- Google exprementerar med SoundScript. Detta är dock i ett extremt tidigt steg så vi får se vart vi hamnar.

- Och att både google och facebook kolla på andra håll är ett tecken på att något är fel.
- Version 2.0 har adreserat många av problemen och det är tal om en total omskrivning. Om detta blir aktuellt så kanske typescript är vägen vi ska ta.
- Just nu är dock typescript det bästa på marknaden tycker jag. Flow är för omoget och SoundScript är i ett extremt tidigt stadium.

Okej, nu är vi redo för Angular 2.
- Hur många är bekanta med Angular 2?
- Hur många är bekanta med angular 1? Hur många vet vad $apply() gör i angular 1?

Låt oss börja med angular 2:

Hur man skapar en komponent i angular 2:

import {Component} from 'angular2/core';

@Component({
    selector: 'my-app',
    template: '<h1>I'm the one who knocks</h1>'
})
class AppComponent { }

export {AppComponent};


import {bootstrap}    from 'angular2/platform/browser'
import {AppComponent} from './app.component'

bootstrap(AppComponent);

